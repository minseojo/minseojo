Chapter 1. 컴퓨터 시스템의 구성

### 저장 장치 구조

### 메모리 계층 구조에 대해  설명해 주세요.

![Untitled](Chapter%201%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%208ad9462bfd284a1191964c2babd2fa34/Untitled.png)

레지스터, 캐시, 메인 메모리는 1차 저장장치로 휘발성 메모리이고, 저장 용량은 적지만 액세스 속도가 빠르다는 장점이 있습니다. 

 하드 디스크는 2차 저장장치로 비휘발성 메모리이고, 대용량 데이터를 영구적으로 저장하는데 목적이 있습니다. 비휘발성 메모리는 전기적 저장장치로 기계적 저장장치인 하드 디스크보다 비싸고 용량이 적지만 속도가 빠릅니다. 

3차 저장장치인 광학 디스크, 자기 테이프 등이 있으며 저장 용량이 가장 크지만 가장 느립니다.

## 인터럽트

### 하드웨어와 CPU사이에 인터럽트가 일어나는 과정을 설명해 주세요.

CPU와 하드웨어에는 인터럽트 요청 라인이 있습니다.

이 선은 명령어 하나를 실행을 할 때 마다 CPU가 이 선을 감지합니다. 즉 장치 컨트롤러가 인터럽트 요청 라인에 신호를 보내면 CPU는 이 신호를 감지하고, 인터럽트 번호를 읽어 인터럽트 벡터로 이동합니다.

최하위 메모리에 있는 인터럽트 벡터는 각 인터럽트에 따른 처리 함수 주소를 가지고 있습니다. 즉 인터럽트 벡터를 통해 인터럽트 서비스 루틴(핸들러 루틴)으로 이동합니다.

인터럽트 서비스 루틴을 이동해서 인터럽트를 처리하기전에 현재주소로 복귀하기 위한 현재정보를 저장하고, 인터럽트를 처리한 이후에 다시 저장한 주소로 복귀합니다.

- 장치 컨트롤러가 인터럽트 요청 라인에 (입출력 요청 등) 신호 보냄 발생(raise)
- CPU는 인터럽트 포착(catch)
- 인터럽트 벡터를통해 인터럽트 핸들러로 이동후   디스패치(dispatch)
- 핸들러는 인터럽트를 지움(clear)

### 인터럽트 요청 라인에는 마스크 가능한 라인과 마스크가 불가능한 라인이 있는데 이 두 개에 대해 설명해 주세요.

CPU에는 마스크 불가능 인터럽트(nonmaskable interupt)라인, 마스크 가능 인터럽트(maskable)라인 2개의  라인이 있습니다.

마스크 불가능 인터럽트(nonmaskable interupt)은 CPU의 명령으로 비활성화하거나 무시할 수 없는 인터럽트입니다. 응답시간이 중요한 경우 또는 나눗셈 에러 0으로 나누는 행위, null 인터럽트 등 컴퓨터 시스템을 처리하기위해 사용합니다.

마스크 가능 인터럽트(maskable)은 CPU의 지시에 따라 비활성화 또는 무시할 수 있는 인터럽트입니다. 이 인터럽트 요청 라인은 장치 컨트롤러인 프린트, 마우스 등이 서비스를 요청하기 위해 사용합니다.

### 여러 종류의 인터럽트를 마스킹 하지 않고 처리하는 방법이 있나요?

각각의 인터럽트마다 우선순위를 둡니다.

## DMA

### 직접 메모리 액세스(DMA)에 대해 설명해 주세요.

![3A18DF2D-925C-41A6-BB57-FDFD3B6530E4.jpeg](Chapter%201%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%208ad9462bfd284a1191964c2babd2fa34/3A18DF2D-925C-41A6-BB57-FDFD3B6530E4.jpeg)

일반적인 인터럽트는 소량의 데이터를 이동하는 데는 좋지만 보조저장장치와 같은 대량의 데이터를 이동시킬때는 높은 오버헤드를 유발합니다. 이 문제를 해결하기 위해 DMA가 사용됩니다.

장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅후 장치 컨트롤러는 CPU 개입 없이 메모리부터 장치로 또는 장치에서 메모리로 데이터 블록 전체를 전송합니다.

일반적인 인터럽트는 한 바이트마다 인터럽트가 발생하지만 DMA는 한 블록마다 인터럽트가 발생합니다.

### DMA를 효과적으로 사용하려면 어떻게 해야 하나요?

버스 대신에 스위치 구조를 사용합니다. 이런 시스템에서는 공유 버스를 사용하기 위해 경쟁을 하지 않고 다른 구성요소 들과 동시에 통신하는 것이 가능합니다.

### 스위치가 DMA에서 무슨 기능을 해주나요?

스위치는 **연결된 장치들의 IP와 MAC 주소를 모두 테이블 형태로 가지고, 원하는 목적지에 데이터 패킷을 전송하는 장치**입니다.

허브와 달리 스위치는 무작정 데이터 패킷을 뿌리는 것이 아니라, IP와 MAC 주소를 기반으로 필요한 장치에게만 데이터 패킷을 전송해 줍니다. 

## 다중 처리기 시스템

### 다중 코어 다중 처리기 시스템에 대해서 설명해 주세요.

우선 단일 코어 다중 처리 시스템은 각 처리기(프로세서)에 CPU가 한개 씩 있는것을 의미 합니다.

다중 코어 다중 처리 시스템은 각 처리기에 CPU가 두 개 이상 있는것을 의미하고 

8개의 코어를 8개의 처리기로 처리하는 방식인 단일 코어 다중 처리 시스템보다 

8개의 코어를 각 처리기마다 코어를 2개씩 4개의 처리기로 처리하는게 효율이 좋습니다. 

왜냐하면 칩 내부의 통신이 칩 외부와의 통신보다 속도가 빠르기 때문입니다. 또한 훨씬 적은 전력을 사용합니다. 

그리고 각 처리기에 각각의 코어끼리 공유하는 L2캐시와 로컬캐시인 L1캐시가 있습니다. 

### L1 캐시와 L2 캐시를 비교해 주세요.

L1 캐시는 처리기안에 각각의 CPU마다 가지고 있는 지역 캐시이고 크기는 작지만 속도가 빠릅니다.

L2 캐시는 처리기 안에 각각의 CPU들이 공유하는 공유 캐시로 크기는 크지만 속도는 느립니다.

### NUMA(non-uniform memory access)에 대해 설명해 주세요.

![9926BDE2-CE7C-4D90-8AC9-5CA61D050182.jpeg](Chapter%201%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%208ad9462bfd284a1191964c2babd2fa34/9926BDE2-CE7C-4D90-8AC9-5CA61D050182.jpeg)

다중 처리기 시스템에 CPU를 추가하여 성능을 올리는데는 한계가 있습니다. (확작성이 좋지 않고, CPU가 너무 많으면 시스템 버스에 병목 현상 증가)

그래서 다른 방법으로  CPU(또는 CPU 그룹)에 작고 빠른 로컬 버스를 통해 액세스 되는 자체 메모리를 제공하는 것 입니다. 즉 모든 CPU가 공유 시스템으로 연결되어 하나의 물리 주소 공간을 공유합니다.

단점으로 자신의 CPU자체 메모리에 액세스 하는 속도가 빠른 만큼 자신이 아닌 다른 CPU의 메모리에 접근할 때 성능이 저하 됩니다. 

### 블레이드 서버에 대해 간단히 설명해 주세요.

각 블레이드 처리기들은 독립적으로 부팅될 수 있고 자기 자신의 운영체제를 수행합니다. 근본적으로 블레이드 서버는 여러 다중 처리기 시스템으로 구성됩니다.

### 클러스터형 시스템

### 클러스터형 시스템에 대해 설명해 주세요.

클러스터 시스템은 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말합니다. 

클러스터의 구성 요소들은 일반적으로 고속의 근거리 통신망(LAN)으로 연결되어 있고 저장장치를 공유합니다.

서버로 사용되는 각 노드들은 각각의 운영체제가 실행되며 다중 코어 시스템 입니다.

클러스터 시스템을 사용하능 이유로는 높은 가용성(availablity)을 제공하기 위해 사용됩니다. 즉, 클러스터 내 하나 이상의 컴퓨터 시스템이 고장 나더라도 서비스를 계속 제공할 수 있습니다.

가용성: 가용성이란 서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도를 말한다.

### 비대칭형 클러스터링과 대칭형 클러스터링에 대해 설명해 주세요.

클러스터링은 비대칭 또는 대칭적으로 구성될 수 있습니다.

비대칭형 클러스터링은 다른 컴퓨터들이 프로그램을 실행하는 동안 한 컴퓨터는 상시 대기(hot-standby) 모드 상태를 유지합니다. 

이 상시 대기 모드 호스트는 활성화된 다른 서버들을 감시하고, 감지하는 서버가 고장 난다면 상시 대기 모드 호스트가 활성 서버가 됩니다.

대칭형 클러스터링은 둘 이상의 호스트들이 프로그램을 실행하고 서로를 감시합니다.

가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적입니다.

클러스터 시스템은 네트워크로 연결된 다수의 컴퓨터 들이 병렬 수행을 하므로 고성능 계산을 제공합니다.

병렬화 기법은 각 컴퓨터에 태스크를 분리하여 준 다음에 각 노드에서 문제를 해결한 후에 모든 노드의 결과를 결합하여 답을 얻습니다.

### 병렬형 클러스터에 대해  설명해 주세요.

병렬 클러스터는 여러 호스트가 공유 저장장치의 동일한 데이터에 동시에(병렬적) 접근할 수 있습니다. 

OS는 일반적으로 동일한 데이터에 동시 접근을 지원하지 않기 때문에 클러스터링 시스템에 자체적으로 접근간의 충돌이 발생하지 않도록 보장하기 위하여 접근 제어와 잠금 기법을 제공하는 분산 잠금 관리자(**Distributed lock manager**, DLM)기능이 포함되어 있습니다. 

실제 병렬 클러스터 예로 Oracle의 데이터 베이스 중 하나가 있습니다.

## 다중 프로그래밍과 다중 태스킹

## 이중모드

### 이중모드에 대해 설명해 주세요.

이중 모드는 잘못된 사용자로부터 운영체제를 보호하는 방법을 제공합니다. 이중모드는 두개의 독립된 연산 모드인 사용자 모드(1)와 커널모드(0)[시스템 모드, 특권 모드]가 있습니다.

그리고 악영향을 끼칠 수 있는 일부 명령을 특권 명령(privulged insruction)으로 지정합니다.

만약 사용자 모드에서 특권 명령을 시도하면, 하드웨어는 이를 실행하지 않고, 운영체제로 트랩을 겁니다.

![5D3EEED9-CA4D-4CFE-BEF5-6DD7A05D2174.jpeg](Chapter%201%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%208ad9462bfd284a1191964c2babd2fa34/5D3EEED9-CA4D-4CFE-BEF5-6DD7A05D2174.jpeg)

사용자 프로그램이 OS로 특권 명령을 요청하면 이 요청을 수행하기 위해서는 사용자 모드에서 커널모드로 전환하고, 시스템 콜을 실행하고 사용자 모드로 복귀합니다.

시스템 콜은 운영 체제의 커널이 제공하는 서비스이고, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 입니다.

시스템 부트 시, 하드웨어는 커널 모드에서 OS가 적재되고, 사용자 모드에서 사용자 프로세스가 시작됩니다. 

그리고 트랩이나 인터럽트가 발생할 때마다 사용자 모드에서 커널 모드로 전환하고 시스템 콜을 실행하고 시스템 콜은 일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취합니다. 그럼 트랩은 인터럽터 서비스 루틴을 실행합니다. 루틴을 다 마치면 사용자 모드로 복귀합니다.

### 특권 명령과 일반 명령에 대해 설명해 주세요.

특권 명령은 커널 모드에서만 수행할 수 있지만,

일반 명령은 커널 모드뿐 만 아니라 사용자 모드에서도 수행됩니다.

### **타이머란 무엇인가요**

CPU 제어가 사용자 프로그램 무한 루프 등으로 운영체제로 복귀하지 않는 것을 방지하기 위해 지정된 시간 후 인터럽트를 발생시키는 것입니다.

 

sleep(1000)는 정확하지 않다.

이 함수는 타이머의 예로 1초동안 CPU제어를 받지 않는 다는 의미이므로 실행큐에서 1초동안 빼둔다. 하지만 프로세스 스케줄링, CPU스케줄링 등의 시간으로 인해 1초보다 더 오래 걸린다.

## 캐시

### 캐시 일관성 문제에 대해 설명해 주세요.

![F4FAE943-282F-43E2-95C4-B3402E6052B9.jpeg](Chapter%201%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%208ad9462bfd284a1191964c2babd2fa34/F4FAE943-282F-43E2-95C4-B3402E6052B9.jpeg)

하드디스크에 F파일이 있다고 가정하고, 변수 A가 있습니다. 이때 A의 값을 바꾸는 과정을 설명하면

하드디스크에 있는 F파일에서 A 를 메인메모리로 가져오고, 메인메모리에서 입출력 연산을 통해 A 값을 바꾼후, A를 캐시에 복사하고 A를 레지스터에 복사합니다.

이때 다중 코어 다중 처리기 환경에서는 CPU 별로 지역 캐시를 가지고 있기 때문에 변수 A가 (현재 코어 뿐만 아니라 다른코어에도) 여러 캐시에(캐시2) 복사되어 있을 수 있습니다. 이런 경우 여러 개의 CPU가 모두 동시에 A에 접근할 수 있으므로 한 캐시에 있는 데이터 값이 갱신되면 다른 캐시에 존재하는 해당 데이터가 모두 즉각적으로 갱신되어야 합니다. 이러한 상황을 캐시 일관성 문제라고 합니다.
<!--
<img src="https://img.shields.io/badge/쓰고자하는_텍스트-컬러코드?style=flat-square&logo=simpleicons에서_아이콘이름&logoColor=white"/></a>

[![Anurag's GitHub stats](https://github-readme-stats.vercel.app/api?username=minseojo&theme=dracula)](https://github.com/minseojo)

-->



![header](https://capsule-render.vercel.app/api?type=Waving&color=003458&height=240&section=header&text=MinseoJo&fontSize=60&animation=blinking&5&fontColor=ffffff)

# 📚 Tech Stack

### Techs that I use the most
<div align="left">
    <img src="https://img.shields.io/badge/C%2B%2B-00599C?style=flat-square&logo=C%2B%2B&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/Java-007396?style=flat-square&logo=Java&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/-SQLite-blue?logo=sqlite"></a>
</div>
<div align="left">
    <img src="https://img.shields.io/badge/Spring-6DB33F?style=flat-square&logo=Spring&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/Spring Boot-6DB33F?style=flat-square&logo=Spring Boot&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/Bootstrap-7952B3?style=flat-square&logo=Bootstrap&logoColor=white"/></a>
</div>


---

### Techs that I use the little
<div align="left">
    <img src="https://img.shields.io/badge/HTML-E34F26?style=flat-square&logo=HTML5&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/CSS-1572B6?style=flat-square&logo=CSS3&logoColor=white"/></a>
    <img src="https://img.shields.io/badge/Java Script-F7DF1E?style=flat-square&logo=JavaScript&logoColor=black"/></a>
</div>







# 😀 Me
### How to reach me
<div align="left">
    <a href="https://velog.io/@minseojo">
        <img src="https://img.shields.io/badge/Blog-20C997?style=flat-square&logo=Velog&logoColor=white"/>
    </a>
    <a href="mailto:liging12@naver.com">
        <img src="https://img.shields.io/badge/Mail-EA4335?style=flat-square&logo=Minutemailer&logoColor=white"/>
    </a>
    
</div>

### Baekjoon

[![Solved.ac Profile](http://mazassumnida.wtf/api/v2/generate_badge?boj=liging)](https://solved.ac/liging/)

### LeetCode

[![Leetcode Stats](https://leetcard.jacoblin.cool/minseojo?theme=dark)](https://leetcode.com/minseojo/)
